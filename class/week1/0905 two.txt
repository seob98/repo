1. git은 하나의 프로젝트에 대해 다양한 사람들이 참가할 수 있도록 프로젝트의 변경을 관리해주는 버전관리 소프트웨어이다. 깃은 자신의 작업물이 다른 사람들의 작업물과 겹쳐쓰이거나 데이터를 잃지 않도록 미연에 방지하는 역할을 한다. 깃은 자신의 작업물과 동료의 작업물을 동시에 보관하고, 두 수정사항 중 어떠한 작업도 잃지 않고 두 수정사항을 병합하는 것이 가능하다. 이전에 행해졌던 변경사항들에 대한 트랙을 "스냅샷"에 저장하기 때문에 이전의 어느 특정한 시점으로 되돌릴 수 있다. 스냅샷의 존재 덕분에 다른 사용자들의 프로젝트를 둘러보며 배울 수 있고, 다른 사용자들 역시 내 프로젝트의 에러등을 찾아 해결법을 제안해줄 수 있다. github는 해당 소프트웨어를 다운함으로써 로컬에서 프로젝트를 관리할 수 있는 비주얼 인터페이스를 제공하고 프로젝트의 버전 관리 등 소셜 네트워크 기능의 사용이 가능하다. 앞써 언급했던 사용자간 프로젝트의 공유도 이에 해당한다.

깃에 대한 기본적인 이해를 위해 알아둬야 하는 용어 5가지 이다.

-커맨드라인: 명령어 입력을 위해 사용하는 프로그램. 마우스 대신 텍스트 기반 명령어들을 사용하기 위해 필요하다.

-저장소(repository): 프로젝트가 존재하는 공간. 사용자의 개인 로컬폴더일 수 있고 깃허브나 다른 온라인 호스트의 저장공간일수도 있다. 흔히 repo라 짧게 칭하고 파일들을 저장하고 이름붙일 수 있다.

-버전관리: 깃이 사용되는 목적. 스냅샷의 존재덕에 워드마냥 번거롭게 여러버전으로 나누어 저장하거나 이전 파일을 덮어 쓸 필요가 없다. 프로젝트 히스토리의 모든 시점으로 되돌릴 수 있기 때문.

-커밋: 스냅샷을 찍어 프로젝트의 체크포인트를 설정한다.

-브랜치: 메인 프로젝트에 브랜치를 따오고, 수정하고, 다시 메인프로젝트에 브랜치를 병합한다. 이 과정을 branch off, merge라고 한다.merge 이전까지는 다른 사람들이 내 작업내역을 확인할 수 없다.

 

대략적인 git의 사용방법은 다음과 같다. (window사용자로 기준)

1. git bash를 사용해 자신의 이름, 이메일을 설정한다.

2. 프로젝트가 거주할 공간인 디지털 디렉토리 혹은 저장소를 설정한다. 앞써 살펴보았던 repo이다.

3. 방금 create repository로 온라인 거주공간을 만들었으니 다음은 로컬 저장소를 설정해야한다.

mkdir 명령어를 내려 내 프로젝트 파일을 만들자. 갓허브 저장소와 동일한 이름을 지어야함을 유의한다.

4.cd(change directory) 명령으로 방금 만든 파일로 움직여 git.init 명령어를 입력해 컴퓨터에게 해당 디렉토리가 깃 저장소임을 인식시킨다. 이걸로 프로젝트가 거주할 온라인 저장소와 로컬 저장소를 마련한 것이다.

5.touch readme.txt를 입력해 readme.txt파일을 만들고 git.status 명령어를 사용해 git이 readme를 주시하고 있는지 아닌지 확인하자. 무시받고 있다면 git.add명령어를 사용해 추가해주자.

git add readme.txt로 처음 파일을 첨가했다. 스냅샷, 즉 이제 체크포인트를 설정해야 한다. git commit 명령어를 사용해 스냅샷을 찍어준다. git commit -m "add readme.txt"

6. 자신의 프로젝트가 저장되어 있는 git사이트에 add,remote명령어를 통해 git이 온라인 저장소의 위치를 확인시켜준다.

로컬 저장소와 깃허브 저장소가 연결되었다면 깃은 원격저장소와 로컬 저장소의 위치, 그리고 변경사항을 어디로 보내줘야 할지 정확히 인식한 것이다.

 

주요 명령어들

git init: 깃 저장소 초기화. 이 명령을 실행한 후 디렉토리에서 git명령어들이 실행 가능해진다.

git config: 깃의 초반 설정에 매우 용이

git status: 깃의 전체적인 상태 파악이 가능하다. 저장소 내용과 로컬 컴퓨터 내용의 차이나 브랜츠 상태나 수정현황등을 전체적으로 파악이 가능하다.

git add: 수정 파일들을 저장소에 올릴 준비를 끝낸다.

git commit -m "커밋내용" : add를 통해 올린 내용을 최종확정본인 head까지 보낸다. 아직 저장소에 수정내용이 올라가진 않았다. 변경사항 이후 저장소의 스냅샷을 찍기 위해 사용된다.

git push: 수정 사항을 저장소에 반영한다.

git clone: 저장소에 있는 내용을 로컬 컴퓨터에 불러온다.

git pull: 수정된 저장소의 내용을 불러온다. clone으로도 같은 효과를 기대할 수 있으나, 수정 사항들만 불러오는 경우 전체 파일들을 다시 받는것은 시간낭비이다. pull은 수정이 필요한 파일들만 갱신한다.

git branch: 자신만의 변경사항 및 커밋 타임라인을 만든다. branch off를 이후 작업을 마무리 하고, merge(병합) 이전까지는 아무도 내 작업내용을 확인할 수 없다.

git merge: 내 branch에서의 변경사항을 master에 추가한다.

 

2.

실제 입력해보며 느낀점 위주로 서술하겠습니다.

>>> r=11

>>> area = pi * r **2

>>> print(area)

380.132632

>>> area>r

True

>>> r= -1

>>> area = pi * r **3

>>> area>r

FALSE

 r에 대한 곱셈인 area도 r과 수의 크기 우위비교가 가능했다

 

>>> score= { 'momo' : 80, 'sana' : 12}

>>> type(score)

>>> score['momo']

80

>>> score['momo'] = 13

>>> score ['momo']

13

>>> 'momo' in score

False

>>> 'sana' in score

True

 dict도 데이터 변경에 제한은 없다. list, dict, tuple, set중 데이터 변경이 불가한건 tuple 뿐인듯하다.

 

>>> s1 = {1,2,3}

>>> type(s1)

<class 'set'>

>>> s2={1,2,2,4}

>>> type(s2)

<class 'set'>

>>> s3={1,1,1,1,2,2,2,3,3,3,3}

>>> type(s3)

<class 'set'>

>>> s4={1,1,1,1}

>>> type(s4)

<class 'set'>

>>> twice = {'sana','sana','sana'}

>>> type(twice)

<class 'set'>

 set는 중복이 되지 않는 것으로 배웠는데 type가 set로 나와서 당황했습니다. set를 뜻하는 {}을 사용하고 내용물을 중복으로 채웠는데 되다니 이상하게 느꼈습니다. 확인을 위해 ppt같이 s1,s2사이 +-등의 식을 사용해봅니다.

 

>>> s1 = {1,2,3}

>>> s2 = {1,2,'sandwich'}

>>> s1-s2

{3}

>>> s1 + s2

Traceback (most recent call last):

  File "<pyshell#65>", line 1, in <module>

    s1 + s2

TypeError: unsupported operand type(s) for +: 'set' and 'set'

>>> s2= {1,2,5}

>>> s1-s2

{3}

 빼기는 문제없으나 더하기는 오류가 생깁니다. s1,s2에게 +연산자는 지원되지 않는다라..

 

>>> s1 = (1,2,5)

>>> type(s1)

<class 'tuple'>

>>> s2 = (1,2,'sandwich')

>>> type(s2)

<class 'tuple'>

>>> s1+s2

(1, 2, 5, 1, 2, 'sandwich')